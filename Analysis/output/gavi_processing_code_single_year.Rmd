---
title: "gavi_processing_code"
output: html_document
params: 
  cholera_directory: "/home/qulu/cmp_report"
  config: "/Analysis/configs/Dec_2021_runs/KEN_2015_2019/config_KEN_2015_2019_censoring.yml"
  old_runs: FALSE
  single_year: FALSE
---

```{r setup, include=FALSE, dev="CairoPNG"}
knitr::opts_chunk$set(
  echo = FALSE,
  dev = "CairoPNG",
  error = FALSE,
  fig.align = "center",
  message = TRUE,
  warning = TRUE
)

library(stringr)
library(dplyr)
library(magrittr)
library(purrr)
library(readr)
library(ggplot2)
library(kableExtra)
library(taxdat)
library(sf)
library(raster)
library(stars)

### other new packages (mainly for "rgeoboundaries")
chooseCRANmirror(ind = 77)

package_list <- c(
  "fasterize",
  "remotes",
  "rgeoboundaries"
)

for (package in package_list) {
  if (!require(package = package, character.only = T)) {
    if (package == "rgeoboundaries") {
      try({
        remotes::install_gitlab("dickoa/rgeoboundaries")
        remotes::install_github("wmgeolab/rgeoboundaries")
      })
    } else {
      install.packages(pkgs = package)
      library(package = package, character.only = T)
    }
  }
  # detach(pos = which(grepl(package, search())))
}
```

```{r load processing functions}
## Method1: create summary values for each layer across cells, then summarize across layers to get CIs.
# for each layer, group the cells by incidence rates (mild, moderate, and high incidence areas)

#' @name crop_to_shapefile
#' @title crop_to_shapefile: crop the raster with country shapefile
#' @param raster: raster file
#' @param shapefile: the country or location shapefile
#' @param snap: in which direct the extext should be aligned to
#' @return cropped and maksed raster
crop_to_shapefile <- function(raster, shapefile, snap) {
  raster_cropped <- raster::crop(raster, extent(shapefile), snap = snap)
  raster_cropped <- raster::mask(raster_cropped, shapefile)
  return(raster_cropped)
}

#' @name get_disaggregated_rate_raster
#' @title get_disaggregated_rate_raster
#' @description get rate raster for each layer
#' @param preprocessed_data_filename
#' @param covar_data_filename
#' @param model_output_filenames
#' @return rate_raster
get_disaggregated_rate_raster <- function(covar_data_filename,
                                          model_output_filenames,
                                          stan_input_filenames,
                                          if_single_year_run) {
  covar_cube_output <- read_file_of_type(covar_data_filename, "covar_cube_output")
  rate_raster <- covar_cube_output$sf_grid
  non_na_gridcells <- taxdat::get_non_na_gridcells(covar_data_filename)
  rate_raster <- rate_raster[non_na_gridcells, ]

  model.rand <- read_file_of_type(model_output_filenames, "model.rand")
  modeled_rates <- exp(as.array(model.rand)[, , grepl(
    "log_lambda",
    names(model.rand)
  ), drop = FALSE])
  modeled_rates_mean_by_grid_layer_tmp <- as.data.frame(t(apply(modeled_rates, c(1, 3), mean))) %>%
    mutate(id = seq_len(dim(modeled_rates)[3]))

  # subset years with obervations
  stan_input <- read_file_of_type(stan_input_filenames, "stan_input")
  if (params$single_year == FALSE) {
    obs_years <- (nrow(modeled_rates_mean_by_grid_layer_tmp) / 5) * ((min(lubridate::year(stan_input$sf_cases_resized$TL)):max(lubridate::year(stan_input$sf_cases_resized$TR))) - 2015)
    modeled_rates_mean_by_grid_layer <- data.frame()
    for (row_idx in unique(obs_years)) {
      tmp <- modeled_rates_mean_by_grid_layer_tmp[(row_idx + 1):(row_idx + nrow(modeled_rates_mean_by_grid_layer_tmp) / 5), ]
      modeled_rates_mean_by_grid_layer <- rbind(modeled_rates_mean_by_grid_layer, tmp)
    }
  } else {
    modeled_rates_mean_by_grid_layer <- modeled_rates_mean_by_grid_layer_tmp
  }

  rate_raster <- merge(rate_raster[rate_raster$long_id %in% unique(modeled_rates_mean_by_grid_layer$id), ], modeled_rates_mean_by_grid_layer, by.x = "long_id", by.y = "id")

  colnames(rate_raster)[str_detect(colnames(rate_raster), ".*[0-9].*")] <- paste0("layer", seq_len(dim(modeled_rates)[1]))
  rate_raster <- rate_raster[, str_detect(colnames(rate_raster), ".*[0-9].*")]

  disaggregated_rate_raster <- raster::raster(rate_raster, res = res(pop_raster_cropped))
  for (layer_idx in seq_len(ncol(rate_raster) - 1)) {
    layer_value <- rate_raster[, layer_idx]
    single_layer <- raster::raster(rate_raster, res = res(pop_raster_cropped))
    single_disaggregated_rate_raster <- fasterize::fasterize(layer_value, single_layer, field = paste0("layer", layer_idx))
    disaggregated_rate_raster <- stack(disaggregated_rate_raster, single_disaggregated_rate_raster)
    rm(single_disaggregated_rate_raster)
    gc()
  }
  names(disaggregated_rate_raster) <- colnames(rate_raster)[-ncol(rate_raster)]
  return(disaggregated_rate_raster)
}

#' @name aggregate_affected_pop_across_cells
#' @title aggregate_affected_pop_across_cells: aggregate proportion of population living in each incidence group across cells for each layer
#' @param pop_raster_cropped: 1*1 KM population raster cropped by crop_to_shapefile function
#' @param rate_raster_cropped: 1*1 KM rate_raster (disaggregated from 20*20 KM rater raster) cropped by crop_to_shapefile function
#' @param shapefile: country shapefile
#' @param threshold_list: the threshold to determine mild/moderate/high incidence areas
#' @return results_by_layer
aggregate_affected_pop_across_cells <- function(pop_raster_cropped, rate_raster_cropped, shapefile, threshold_list) {
  threshold_list <- threshold_list[order(threshold_list, decreasing = T)]
  pop_prop <- as.data.frame(matrix(NA, nrow = 1, ncol = length(unique(threshold_list))))
  names(pop_prop) <- paste0(">=", threshold_list)
  for (threshold_idx in seq_len(length(threshold_list))) {
    pop_prop[, threshold_idx] <-
      100 * sum(values(pop_raster_cropped)[values(rate_raster_cropped) >= threshold_list[threshold_idx]], na.rm = T) /
        sum(values(pop_raster_cropped), na.rm = T)
  }
  pop_prop <- t(t(cbind(0, pop_prop)) - dplyr::lag(t(cbind(0, pop_prop))))[, -1]
  return(pop_prop)
}
```

```{r load data}
config <- yaml::read_yaml(paste0(params$cholera_directory, params$config))
file_names <- taxdat::get_filenames(config, params$cholera_directory)
file_names <- update_filename_oldruns(filename = file_names, old_runs = params$old_runs)
if (params$old_runs) {
  file_names[["stan_output"]] <- stringr::str_remove(file_names[["stan_output"]], "iv-wN-cwN-csF-teT-teaF-weF.")
  file_names[["stan_output"]] <- stringr::str_remove(file_names[["stan_output"]], "-F")
}

iso_code <- as.character(stringr::str_extract(params$config, "[A-Z]{3}"))
shapefile <- rgeoboundaries::gb_adm0(iso_code)
pop_raster <- raster(paste0(params$cholera_directory, "/Layers/pop/2000_1km_Aggregated.tif"))
pop_raster_cropped <- crop_to_shapefile(raster = pop_raster, shapefile = shapefile, snap = "out")
pop_raster_cropped <- aggregate(pop_raster_cropped, 5)

disaggregated_rate_raster <- get_disaggregated_rate_raster(
  covar_data_filename = file_names[["covar"]],
  model_output_filenames = file_names[["stan_output"]],
  stan_input_filenames = file_names[["stan_input"]],
  if_single_year_run = params$single_year
)

rate_raster_cropped <- crop_to_shapefile(raster = disaggregated_rate_raster, shapefile = shapefile, snap = "out")
rm(disaggregated_rate_raster)
gc()
```

```{r processing}
results_by_layer <- list()
for (layer_idx in seq_len(nlayers(rate_raster_cropped))) {
  results_by_layer[[layer_idx]] <- aggregate_affected_pop_across_cells(
    pop_raster_cropped = pop_raster_cropped,
    rate_raster_cropped = rate_raster_cropped[[layer_idx]],
    shapefile = shapefile,
    threshold_list = c(0.001, 0.0001, 0.00001)
  )
}
pop_prop <- data.frame(do.call("rbind", results_by_layer))

year_list <- str_sub(params$config, -8, -5)

filename <- paste0("pop_single_year_", iso_code, year_list, ".csv")
write.csv(pop_prop, filename)
kableExtra::kable(pop_prop)
```
