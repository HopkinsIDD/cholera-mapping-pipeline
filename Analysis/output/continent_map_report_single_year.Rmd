---
  title: "Country data report"
output: html_document
params:
  cholera_directory: "/home/app/cmp/"
config_filename: "/home/app/cmp/Analysis/R/test_config.yml"
drop_nodata_years: TRUE
ncols: 10
nrows: 10
data_type: "Grid data"
oc_type: "Multiple OCs"
polygon_type: "Fake polygons"
polygon_coverage: 0.9
randomize: TRUE
ncovariates: 3
single_year_run: "no"
iteration: 10000
nonspatial: c(FALSE, FALSE,FALSE)
nontemporal: c(FALSE, FALSE,FALSE)
spatially_smooth: c(TRUE, TRUE,TRUE)
temporally_smooth: c(FALSE, FALSE,FALSE)
polygonal: c(TRUE, TRUE,TRUE,)
radiating: c(FALSE,  FALSE,FALSE)
constant: c(FALSE,FALSE,FALSE)
Data_simulation_covariates: c(TRUE,TRUE,TRUE)
Model_covariates: c(TRUE,TRUE,FALSE)
Observations_with_inconsistent_data: "no"
Loc_with_inconsistent_data: "no"
Cov_data_simulation_filename: "/home/app/cmp/Analysis/output/data_simulation_covariates.rdata"

---
  
  ```{r setup, include=FALSE, dev="CairoPNG"}
knitr::opts_chunk$set(
  echo = FALSE,
  dev = "CairoPNG",
  error = FALSE,
  fig.align = "center",
  message = TRUE,
  warning = TRUE
)
library(stringr)
library(dplyr)
library(magrittr)
library(purrr)
library(readr)
library(ggplot2)
library(kableExtra)
library(taxdat)
library(sf)

if (!("params" %in% ls())) {
  params <- list(
    cholera_directory = "/home/app/cmp/",
    config_filename = "/home/app/cmp/Analysis/R/test_config.yml",
    drop_nodata_years = TRUE,
    ncols = 10,
    nrows = 10,
    data_type = "Grid data",
    oc_type = "Multiple OCs",
    polygon_type = "Fake polygons",
    grid_coverage_type = "90%",
    randomize = "TRUE",
    ncovariates = 2,
    single_year_run = "no",
    iteration = 10000,
    nonspatial = c(FALSE, FALSE),
    nontemporal = c(FALSE, FALSE),
    spatially_smooth = c(TRUE, FALSE),
    temporally_smooth = c(FALSE, FALSE),
    polygonal = c(TRUE, TRUE),
    radiating = c(FALSE, FALSE),
    constant = c(FALSE, FALSE),
    Data_simulation_covariates = c(TRUE, TRUE),
    Model_covariates = c(TRUE, TRUE),
    Observations_with_inconsistent_data = "no",
    Loc_with_inconsistent_data = "no"
  )
}
```

# Mapping results summary for `r params$config_filename`

``` {r echo=FALSE}
params_table <- data.frame(do.call(rbind, params))

row.names(params_table) <- c(
  "config_filename",
  "cholera_directory",
  "drop_nodata_years",
  "Grid by rows",
  "Grid by cols",
  "Data",
  "OC",
  "Polygon",
  "Proportion of grids observed",
  "Randomize",
  "Number of covariates",
  "Single_year_run",
  "Iteration",
  "\u00A0\u00A0\u00A0Spatially-varied layers",
  "\u00A0\u00A0\u00A0Temporally-varied layers",
  "\u00A0\u00A0\u00A0Spatially smoothed",
  "\u00A0\u00A0\u00A0Temporally smoothed",
  "\u00A0\u00A0\u00A0Polygonal layer",
  "\u00A0\u00A0\u00A0Radiating layer",
  "Constant",
  "Data_simulation_covariates",
  "Model_covariates",
  "Locations with inconsistent data\n (compared to the country level)",
  "Loc with inconsistent data",
  "Cov_data_simulation_filename"
)

data.frame(parameter = rownames(params_table)[c(1:11, 23)], params_table[c(1:11, 23), 1]) %>%
  kableExtra::kable(
    col.names = c("Parameter", "Values"),
    caption = "Table 1. Parameters"
  ) %>%
  kableExtra::kable_styling(bootstrap_options = c("striped"))
```

``` {r echo=FALSE}
covar <- data.frame(t(params_table[c(14:19, 21, 22), ]))
rownames(covar) <- paste("Covariate", 1:ncol(params_table))
rownames(covar)[1] <- "Population"
covar_table <- covar %>%
  kableExtra::kable(
    col.names = c(
      "Spatially-varied layers",
      "Temporally-varied layers",
      "Spatially smoothed",
      "Temporally smoothed",
      "Polygonal layer",
      "Radiating layer",
      "Data simulation covariates",
      "Model covariates"
    ),
    caption = "Table 2. Covariates"
  ) %>%
  kableExtra::kable_styling(bootstrap_options = c("striped"))


if (stringr::str_detect(params$oc_type, "Multiple test observations")) {
  covar <- data.frame(t(params_table[c(14:19, 21, 22), ]))
  rownames(covar) <- paste("Covariate", 1:ncol(params_table))
  rownames(covar)[1] <- "Population"
  covar_table <- covar %>%
    kableExtra::kable(
      col.names = c(
        "Spatially-varied layers",
        "Temporally-varied layers",
        "Spatially smoothed",
        "Temporally smoothed",
        "Polygonal layer",
        "Radiating layer",
        "Data simulation covariates",
        "Model covariates"
      ),
      caption = "Table 2. Covariates"
    ) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped"))

  observation_groups <- nrow(covar) / params$ncovariates
  rownames(covar)[seq(1, nrow(covar) + 1 - params$ncovariates, params$ncovariates)] <- paste("Population", 1:observation_groups)
  rownames(covar)[-seq(1, nrow(covar) + 1 - params$ncovariates, params$ncovariates)] <- paste(paste("Covariate", 2:params$ncovariates), paste0("G", 1:observation_groups))
  covar_table <- covar %>%
    kableExtra::kable(
      col.names = c(
        "Spatially-varied layers",
        "Temporally-varied layers",
        "Spatially smoothed",
        "Temporally smoothed",
        "Polygonal layer",
        "Radiating layer",
        "Data simulation covariates",
        "Model covariates"
      ),
      caption = "Table 2. Covariates"
    ) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped"))

  # group index for row headers for different test observations
  group_index <- data.frame(matrix(ncol = observation_groups, nrow = 1, data = c(rep(params$ncovariates, observation_groups))))
  colnames(group_index) <- paste("Test observations", 1:observation_groups)
  covar_table %>%
    group_rows(index = group_index)
} else {
  covar <- data.frame(t(params_table[c(14:19, 21, 22), ]))
  rownames(covar) <- paste("Covariate", 1:ncol(params_table))
  rownames(covar)[1] <- "Population"
  covar %>%
    kableExtra::kable(
      col.names = c(
        "Spatially-varied layers",
        "Temporally-varied layers",
        "Spatially smoothed",
        "Temporally smoothed",
        "Polygonal layer",
        "Radiating layer",
        "Data simulation covariates",
        "Model covariates"
      ),
      caption = "Table 2. Covariates"
    ) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped"))
}
```

## Cholera input data
**Data input:**
  
  ```{r load data}

# Load data directory
config <- yaml::read_yaml(params$config_filename)

file_names <- taxdat::get_filenames(config, params$cholera_directory)

stan_input <- taxdat::read_file_of_type(file_names[["stan_input"]], "stan_input")

sf_cases_resized <- stan_input$observation_data

model.rand <- taxdat::read_file_of_type(file_names[["stan_output"]], "model.rand")
niter_per_chain <- dim(MCMCvis::MCMCchains(model.rand, params = "lp__", chain_num = 1))[1]
nchain <- dim(MCMCvis::MCMCchains(model.rand, params = "lp__"))[1] / niter_per_chain
stan_output <- lapply(rstan::extract(model.rand), function(x) {
  array(x, c(niter_per_chain, nchain, dim(x)[-1]))
})
cases_chains <- apply(stan_output$grid_cases, c(3, 2), mean)
```


```{r disjoint set sf cases}
# disjoint_set_sf_cases <- taxdat::get_disjoint_set_sf_cases(stan_input_filename = file_names[["stan_input"]])
disjoint_set_sf_cases <- sf::st_as_sf(stan_input$observation_data)
disjoint_set_sf_cases <- disjoint_set_sf_cases %>%
  rename(cases = suspected_cases) %>%
  mutate(area = as.numeric(sf::st_area(disjoint_set_sf_cases)) / 1000 / 1000, area_adjusted_cases = cases / area)


disjoint_set_sf_cases <- dplyr::arrange(
  disjoint_set_sf_cases,
  -area
)
overlaps <- sf::st_relate(
  disjoint_set_sf_cases, disjoint_set_sf_cases,
  "2********"
)
non_overlapping_sets <- list()
disjoint_set_sf_cases$not_included <- TRUE
index <- 0
while (any(disjoint_set_sf_cases$not_included)) {
  leftovers <- which(disjoint_set_sf_cases$not_included)
  index <- index + 1
  non_overlapping_sets[[index]] <- NA
  not_allowed <- NA
  for (idx in leftovers) {
    if (idx %in% not_allowed) {
    } else {
      disjoint_set_sf_cases$not_included[idx] <- FALSE
      non_overlapping_sets[[index]] <- c(
        non_overlapping_sets[[index]],
        idx
      )
      not_allowed <- sort(unique(c(not_allowed, overlaps[[idx]])))
    }
  }
  non_overlapping_sets[[index]] <- non_overlapping_sets[[index]][!is.na(non_overlapping_sets[[index]])]
}
disjoint_set_sf_cases$set <- as.integer(NA)
for (set in seq_len(length(non_overlapping_sets))) {
  disjoint_set_sf_cases$set[non_overlapping_sets[[set]]] <- set
}
```


```{r rawobsmap, fig.height=5, fig.width=10, fig.cap="Figure 1. Observed case counts by time adjusted for time fraction cases/year"}
# taxdat::plot_raw_observed_cases(
#   disjoint_set_sf_cases,
#   render = T
# )
disjoint_set_sf_cases <- disjoint_set_sf_cases %>% mutate(lon = map_dbl(shape, ~ sf::st_centroid(.x)[[1]]), lat = map_dbl(shape, ~ sf::st_centroid(.x)[[2]]))

plt <- ggplot2::ggplot()

if (all(params$Loc_with_inconsistent_data == "no")) {
  # plt <- plt +
  #   ggplot2::geom_sf(
  #     data = disjoint_set_sf_cases,
  #     ggplot2::aes(fill = cases)
  #   ) +
  #   ggplot2::labs(fill="Average cases by location period")+
  #   ggplot2::theme_bw() +
  #   ggplot2::theme(legend.position = "bottom") +
  #   ggplot2::facet_wrap(~set)+
  #   taxdat::color_scale(type = "case", use_case = "ggplot map", use_log = FALSE)
  #
  disjoint_set_sf_cases %>%
    group_by(set) %>%
    do(gg = {
      ggplot(., ggplot2::aes(fill = cases)) +
        ggplot2::geom_sf() +
        taxdat::color_scale(type = "case", use_case = "ggplot map", use_log = FALSE) +
        ggplot2::labs(fill = "Average cases by location period") +
        ggplot2::theme_bw() +
        ggplot2::theme(legend.position = "bottom") +
        ggplot2::facet_wrap(~set)
    }) %>%
    .$gg %>%
    gridExtra::grid.arrange(grobs = ., nrow = 1)
} else {
  # plt <- plt +
  #   ggplot2::geom_sf(
  #     data = disjoint_set_sf_cases,ggplot2::aes(fill = cases)) +
  #   ggplot2::geom_point(data=disjoint_set_sf_cases%>%subset(location_name%in%params$Loc_with_inconsistent_data),
  #                       aes(x=lon,y=lat),shape=8)+
  #   taxdat::color_scale(type = "case", use_case = "ggplot map", use_log = FALSE)+
  #   ggplot2::labs(fill="Average cases by location period",shape="Locations with \ninconsistent data")+
  #   ggplot2::theme_bw() +
  #   ggplot2::theme(legend.position = "bottom") +
  #   ggplot2::facet_wrap(~set
  disjoint_set_sf_cases %>%
    group_by(set) %>%
    do(gg = {
      ggplot(., ggplot2::aes(fill = cases)) +
        ggplot2::geom_sf() +
        ggplot2::geom_point(
          data = disjoint_set_sf_cases %>% subset(location_name %in% params$Loc_with_inconsistent_data),
          aes(x = lon, y = lat), shape = 8
        ) +
        taxdat::color_scale(type = "case", use_case = "ggplot map", use_log = FALSE) +
        ggplot2::labs(fill = "Average cases by location period", shape = "Locations with \ninconsistent data") +
        ggplot2::theme_bw() +
        ggplot2::theme(legend.position = "bottom") +
        ggplot2::facet_wrap(~set)
    }) %>%
    .$gg %>%
    gridExtra::grid.arrange(grobs = ., nrow = 1)
}
# plt
```

```{r areadjustedmap, fig.height=5, fig.width=10, fig.cap="Figure 2. Area adjusted average observed case counts by time adjusted for time fraction cases/(year * kilometer)"}
taxdat::plot_area_adjusted_observed_cases(
  disjoint_set_sf_cases,
  render = T
)
```

## Covariates

```{r covars, fig.height=5, fig.width=8, fig.cap="Figure 3.1 Covariate rasters in modeling process"}
# taxdat::plot_raster_covariates(covar_data_filename = file_names["covar"], render = T)

loc_sf <- stan_input$observation_data[, colnames(stan_input$observation_data) %in% c("shape", "location_name")]
covar_grid <- merge(stan_input$temporal_location_grid_mapping, stan_input$covar_cube, by = c("spacetime_grid_id", "x", "y", "rid", "t"))
pltdata <- merge(covar_grid, loc_sf, by.x = "qualified_name", by.y = "location_name")
pltdata <- sf::st_as_sf(pltdata)
pltdata$t <- as.factor(pltdata$t)
levels(pltdata$t) <- 1:nlevels(pltdata$t)

pltdata_dummy <- tidyr::gather(dplyr::filter(pltdata, t == 1 & !qualified_name == "1"), one_of(colnames(pltdata)[stringr::str_detect(colnames(pltdata), "covariate|pop")]), key = "covars", value = "value") %>% subset(!covars == "covariate_contribution")

pltdata_dummy %>%
  group_by(covars) %>%
  do(gg = {
    ggplot(., ggplot2::aes(fill = value, color = value)) +
      ggplot2::geom_sf() +
      ggplot2::facet_wrap(~covars) +
      ggplot2::scale_fill_viridis_c(
        aesthetics = c("colour", "fill"),
        guide = ggplot2::guide_colorbar(title = "Covariate at time 1"),
        option = "B", na.value = "white"
      ) +
      ggplot2::theme_bw() +
      ggplot2::theme(
        legend.position = "bottom",
        legend.key.size = unit(0.5, "cm"),
        legend.title = element_text(size = 10)
      )
  }) %>%
  .$gg %>%
  gridExtra::grid.arrange(grobs = ., nrow = 1)
```

``` {r covars_data_simulation, fig.height=5, fig.width=8, fig.cap="Figure 3.2. Non-population covariate rasters in data simulation process"}
# plot the unused covariates
data_simulation_covs <- readRDS(params$Cov_data_simulation_filename)

covdata <- as.data.frame(do.call(rbind, data_simulation_covs[1:(length(data_simulation_covs) - 1)])) %>%
  mutate(value = covariate, covariate = paste("Covariate", rep(2:length(data_simulation_covs), each = nrow(data_simulation_covs[[1]])))) # Convert list to data frame columns
covdata <- sf::st_as_sf(covdata)

covdata %>%
  group_by(covariate) %>%
  do(gg = {
    ggplot(., ggplot2::aes(fill = value, color = value)) +
      ggplot2::geom_sf() +
      ggplot2::facet_wrap(~covariate) +
      ggplot2::scale_fill_viridis_c(
        aesthetics = c("colour", "fill"),
        guide = ggplot2::guide_colorbar(title = "Cvariates in data simulation"),
        option = "B", na.value = "white"
      ) +
      ggplot2::theme_bw() +
      ggplot2::theme(
        legend.position = "bottom",
        legend.key.size = unit(0.5, "cm"),
        legend.title = element_text(size = 10)
      )
  }) %>%
  .$gg %>%
  gridExtra::grid.arrange(grobs = ., nrow = 1)
```

## Output maps

```{r analysisyears}
analysis_years <- lubridate::year(config$general$start_date):lubridate::year(config$general$end_date)
obs_years <- min(lubridate::year(stan_input$observation_data$time_left)):max(lubridate::year(stan_input$observation_data$time_right))
```


```{r importcase}
pre_case_raster <- taxdat::get_case_raster(
  stan_input_filename = file_names[["stan_input"]],
  model_output_filenames = file_names[["stan_output"]]
)
loc_sf <- stan_input$observation_data[, colnames(stan_input$observation_data) %in% c("shape", "location_name")]
covar_grid <- merge(stan_input$temporal_location_grid_mapping %>% subset(!qualified_name == 1), stan_input$covar_cube, by = c("spacetime_grid_id", "x", "y", "rid", "t"))
empty_raster <- merge(covar_grid, loc_sf, by.x = "qualified_name", by.y = "location_name") %>% select("updated_id", "x", "y", "qualified_name", "shape", "t")

case_raster <- merge(pre_case_raster, empty_raster, by = c("x", "y", "t", "updated_id"))

case_raster <- sf::st_as_sf(case_raster)
case_raster$t <- as.factor(case_raster$t)
levels(case_raster$t) <- 1:nlevels(case_raster$t)

if (all(analysis_years %in% obs_years)) {
  message("All analysis years are represented by OCs.")
} else {
  drop_year_ix <- which(!analysis_years %in% obs_years)
  message(paste(paste(analysis_years[drop_year_ix], collapse = ", "), "are not represented in OCs"))
  if (params$drop_nodata_years) {
    message(paste("Dropping", paste(analysis_years[drop_year_ix], collapse = ", "), "from case_raster"))
    case_raster <- dplyr::filter(case_raster, !(t %in% drop_year_ix))
  }
}
```

```{r caserast, fig.cap="Figure 4. Modeled cases", fig.height=5, fig.width=10}
if (!is.null(case_raster)) {
  # taxdat::plot_modeled_cases(case_raster, render = T)

  case_raster_case <- case_raster %>%
    dplyr::select(
      dplyr::contains("modeled cases"),
      id, t
    ) %>%
    tidyr::gather(dplyr::contains("iterations: Chain"),
      key = "chain", value = "value"
    ) %>%
    dplyr::mutate(chain = stringr::str_replace(
      chain,
      "modeled cases", ""
    ))
  case_raster_case$t <- as.numeric(case_raster_case$t)
  plt <- ggplot2::ggplot()
  plt <- plt +
    ggplot2::geom_sf(
      data = case_raster_case,
      ggplot2::aes(fill = value), color = "black", size = 0.05
    ) +
    taxdat::color_scale(type = "cases", use_case = "ggplot map", use_log = TRUE) +
    ggplot2::labs(fill = "Incidence\n [cases/year]") +
    ggplot2::theme_bw() +
    ggplot2::theme(legend.position = "bottom") +
    # ggplot2::facet_wrap(~t,ncol = 2) +
    ggplot2::theme(legend.text = ggplot2::element_text(angle = 45, vjust = 1, hjust = 1))

  plt
} else {
  warning("case_raster is NULL")
}
```

```{r raterast, fig.cap="Figure 5. Modeled rates", fig.height=5, fig.width=10}
if (!is.null(case_raster)) {
  # taxdat::plot_modeled_rates(case_raster, render = T)
  case_raster_rate <- case_raster %>%
    dplyr::select(
      dplyr::contains("modeled rates"),
      id, t
    ) %>%
    tidyr::gather(dplyr::contains("iterations: Chain"),
      key = "chain", value = "value"
    ) %>%
    dplyr::mutate(chain = stringr::str_replace(
      chain,
      "modeled rates", ""
    ))

  case_raster_rate$t <- as.numeric(case_raster_rate$t)

  plt <- ggplot2::ggplot()
  plt <- plt +
    ggplot2::geom_sf(
      data = case_raster_rate,
      ggplot2::aes(fill = value), color = "black", size = 0.05
    ) +
    taxdat::color_scale(type = "test case rates", use_case = "ggplot map", use_log = TRUE) +
    ggplot2::labs(fill = "Incidence rate\n [cases/100'000/year]") +
    ggplot2::theme_bw() +
    ggplot2::theme(legend.position = "bottom") +
    # ggplot2::facet_wrap(~t,ncol = 2) +
    ggplot2::theme(legend.text = ggplot2::element_text(angle = 45, vjust = 1, hjust = 1))

  plt
} else {
  warning("case_raster is NULL")
}
```

## Validation

```{r import_modelfidel}
# data_fidelity <- get_data_fidelity(
#   stan_input_filenames = file_names[["stan_input"]],
#   model_output_filenames = file_names[["stan_output"]]
# )
stan_input_filenames <- file_names[["stan_input"]]
model_output_filenames <- file_names[["stan_output"]]
if (length(stan_input_filenames) != length(model_output_filenames)) {
  stop("Need to provide same number of stan_input and stan_output files")
}
rc <- list()
layer_index <- 1
for (i in 1:length(model_output_filenames)) {
  filename <- model_output_filenames[i]
  model.rand <- read_file_of_type(filename, "model.rand")
  nchain <- dim(MCMCvis::MCMCchains(model.rand, params = "lp__"))[1] / niter_per_chain
  stan_data <- read_file_of_type(
    stan_input_filenames[i],
    "stan_input"
  )$stan_data
  modeled_cases <- as.array(model.rand)[, , grepl(
    "modeled_cases",
    names(model.rand)
  ), drop = FALSE]
  modeled_cases_chain_mean <- apply(modeled_cases, c(
    2,
    3
  ), mean)
  actual_cases <- matrix(stan_data$y, nrow(modeled_cases_chain_mean),
    ncol(modeled_cases_chain_mean),
    byrow = TRUE
  )
  dimnames(actual_cases) <- dimnames(modeled_cases_chain_mean)
  modeled_cases_chain_mean <- reshape2::melt(modeled_cases_chain_mean)
  actual_cases <- reshape2::melt(actual_cases)
  actual_cases$censoring <- rep(stan_data$censoring_inds,
    each = nchain
  )
  actual_cases$oc_uid <- rep(taxdat::read_file_of_type(
    stan_input_filenames[i],
    "stan_input"
  )$sf_cases_resized$OC_UID, each = nchain)
  actual_cases$oc_year <- rep(format(taxdat::read_file_of_type(
    stan_input_filenames[i],
    "stan_input"
  )$sf_cases_resized$TR, "%Y"),
  each = nchain
  )
  comparison <- dplyr::left_join(modeled_cases_chain_mean,
    actual_cases,
    by = c(chains = "chains", parameters = "parameters")
  )
  names(comparison)[3:4] <- c("modeled cases", "actual cases")
  rc[[filename]] <- comparison
  names(rc)[[layer_index]] <- paste(
    paste(filename_to_stubs(filename)[2:3],
      collapse = " "
    ), "\niterations: Chain",
    filename_to_stubs(filename)[5]
  )
  layer_index <- layer_index + 1
}

data_fidelity <- rc
```

```{r datafidelity, fig.cap="Figure 6. Observations vs. modeled cases", fig.height=6, fig.width=6}

if (!is.null(data_fidelity)) {
  # taxdat::plot_model_fidelity(data_fidelity = data_fidelity,case_raster=case_raster,render = T)
  plt <- ggplot2::ggplot(data_fidelity[[1]]) +
    ggplot2::geom_point(ggplot2::aes(y = `modeled cases`, x = `actual cases`, col = chains)) +
    ggplot2::geom_abline(intercept = 0, slope = 1) +
    ggplot2::coord_fixed(ratio = 1, xlim = c(1, max(data_fidelity[[1]][, 3:4])), ylim = c(1, max(data_fidelity[[1]][, 3:4]))) +
    ggplot2::theme_bw()
  plt
} else {
  warning("data_fidelity is NULL")
}
```

```{r traceplots, fig.height=8, fig.width=10, fig.cap="Figure 7. Stan trace plots"}

if (!is.null(model.rand)) {
  ## No eta in the model right now
  ## taxdat::plot_chain_convergence(file_names[["stan_output"]], pars =  c("rho", "betas", "log_std_dev_w", "eta"), render = T)
  taxdat::plot_chain_convergence(file_names[["stan_output"]], pars = c("rho", "betas", "log_std_dev_w"), render = T)
}
```


```{r params, fig.height=6, fig.width=6, fig.cap="Figure 8. Parameter posteriors"}
if (!is.null(model.rand)) {
  ## No eta in the model right now
  ## rstan::plot(model.rand, pars =  c("rho", "betas", "log_std_dev_w", "eta"))
  rstan::plot(model.rand, pars = c("rho", "betas", "log_std_dev_w"))
} else {
  warning("model.rand is NULL")
}
```

```{r rhat, fig.height=5, fig.width=10, fig.cap="Figure 9. Gelman-Rubin Rhat"}
if (!is.null(model.rand)) {
  taxdat::plot_rhat(model.rand, render = T)
} else {
  warning("model.rand is NULL")
}
```

## Table 3. Estimated cases by chain and time slice

```{r cases_chain_table, fig.width=10, fig.cap = "Sum of grid cases by chain and year"}

if (!is.null(model.rand) && !is.null(stan_input)) {
  covar_cube <- stan_input$covar_cube
  covar_cube[, paste("cases", "chain", seq_len(ncol(cases_chains)), sep = "_")] <- cases_chains

  if (params$drop_nodata_years & !all(analysis_years %in% obs_years)) {
    drop_year_ix <- which(!analysis_years %in% obs_years)
    message(paste("Dropping", paste(analysis_years[drop_year_ix], collapse = ", "), "from cases_chains"))
    covar_cube[, paste("cases", "chain", drop_year_ix, sep = "_")] <- NULL
    stan_input$sf_grid <- dplyr::filter(stan_input$sf_grid, !(t %in% drop_year_ix))
  }

  warning("This plot says years but it lies unless the time slices are years")
  by_years <- covar_cube %>%
    dplyr::group_by(t) %>%
    dplyr::summarise(dplyr::across(dplyr::contains("cases_chain"), sum)) %>%
    dplyr::mutate(t = as.character(t))
  mai <- by_years %>%
    dplyr::summarise(dplyr::across(dplyr::contains("cases_chain"), mean)) %>%
    dplyr::mutate(t = "mean annual cases")

  dplyr::bind_rows(by_years, mai) %>%
    kableExtra::kable(col.names = c("time slice", paste("chain", 1:nchain))) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped"))
} else {
  warning("stan_input is NULL")
}
```

```{r full country modeled cases, fig.cap = "comparison with WHO Output"}

if (!is.null(stan_input$observation_data) & !is.null(model.rand)) {
  grid_cases_mean <- apply(cases_chains, 1, mean)
  total_cases <- sum(grid_cases_mean)
  print(paste("There are", format(round(total_cases), big.mark = ","), "total cases"))
} else {
  warning("chains was not extracted from model.rand")
}
```
