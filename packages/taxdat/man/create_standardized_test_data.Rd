% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulation_framework_helpers.R
\name{create_standardized_test_data}
\alias{create_standardized_test_data}
\title{create_standardized_test_data}
\usage{
create_standardized_test_data(
  nrows = 20,
  ncols = 20,
  nlayers = 12,
  base_number = 5,
  n_layers = 3,
  factor = 2,
  snap = FALSE,
  randomize = FALSE,
  ncovariates = 5,
  nonspatial = c(TRUE, FALSE, FALSE, FALSE, FALSE),
  nontemporal = c(FALSE, TRUE, FALSE, FALSE, FALSE),
  spatially_smooth = c(FALSE, FALSE, TRUE, TRUE, FALSE),
  temporally_smooth = c(FALSE, FALSE, FALSE, TRUE, FALSE),
  polygonal = c(TRUE, FALSE, FALSE, FALSE, FALSE),
  radiating = c(FALSE, TRUE, FALSE, FALSE, TRUE),
  constant = c(FALSE, FALSE, FALSE, FALSE, FALSE),
  rho = rep(0.999999, times = ncovariates),
  radiating_polygons = list(NA, create_test_polygons(dimension = 0, number = 2), NA,
    NA, sf::st_union(create_test_polygons(dimension = 1))),
  radiation_function = rep(list(function(x, mu) {     mu * exp(-(x/10000)^2) }),
    ncovariates),
  radiating_means = list(NA, rnorm(2), NA, NA, 1),
  smoothing_function = rep(list(function(n, mu, covariance, centers) {    
    return(scale(MASS::mvrnorm(n = n, mu = mu, Matrix::solve(covariance)))) }),
    ncovariates),
  weights = rep(list(c(0.3, 1, 1, 1, 1)), ncovariates),
  magnitude = c(6, rnorm(ncovariates - 1)),
  family = "Gaussian",
  normalization = function(x) {     if (length(unique(x[])) == 1) {         return(x *
    0 + 1)     }     x <- exp(x)     x[] <- 0.1 * ((x[] - min(x[]))/(max(x[]) -
    min(x[])))     return(x) },
  grid_proportion_observed = 1,
  number_draws = 1,
  grid_spatial_observation_bias = TRUE,
  grid_temporal_observation_bias = TRUE,
  grid_value_observation_bias = TRUE,
  noise = FALSE,
  polygon_proportion_observed = 0.1,
  polygon_observation_rates = exp(rnorm(nrow(test_polygons), -1)),
  polygon_observation_idx = NA,
  polygon_size_bias = TRUE,
  nonlinear_covariates = FALSE,
  min_time_left = lubridate::ymd("2000-01-01"),
  max_time_right = lubridate::ymd("2000-01-01"),
  seed
)
}
\arguments{
\item{nrows}{integer The number of rows the raster should have.}

\item{ncols}{integer The number of columns the raster should have.}

\item{nlayers}{integer The number of layers the raster should have.  Each layer is intended to express time.}

\item{base_number}{integer The number of polygons in the coarsest layer}

\item{n_layers}{integer The number of layers of polygons to make.}

\item{factor}{integer The factor by which to increase the number of polygons between layers}

\item{snap}{boolean Whether to snap the edges of the polygon to the boundaries of raster cells}

\item{randomize}{boolean Whether to randomly generate the polygons (as opposed to uniformly)}

\item{ncovariates}{integer the number of covariates to make}

\item{nonspatial}{boolean(ncovariates) Whether the independent layer varies in space for each covariate}

\item{nontemporal}{boolean(ncovariates) Whether the independent layer varies in time for each covariate}

\item{spatially_smooth}{boolean(ncovariates) Whether the locally correlated layer is spatially correlated for each covariate}

\item{temporally_smooth}{boolean(ncovariates) Whether the locally correlated layer is temporally correlated for each covariate}

\item{polygonal}{boolean(ncovariates) Whether to include the polygonal layer for each covariate}

\item{radiating}{boolean(ncovariates) Whether to include the radiating layer for each covariate}

\item{constant}{boolean(ncovariates) Whether to include the constant layer for each covariate}

\item{rho}{numeric(ncovariates) A parameter governing spatial correlation used to determine the covariance matrix for each covariate}

\item{radiating_polygons}{list(sf::sf) The polygons that the radiating layer radiates from for each covariate}

\item{radiation_function}{function(x, mu) The function that determines the decayed value x units away from a polygon of value mu}

\item{radiating_means}{list(numeric()) A list with one element for each covariate.  The list elements should have a number for each radiating_polygon for that covariate which is the value that radiates away from that polygon}

\item{smoothing_function}{list(function(n ,mu, covariance, centers)) The function to determine the smooth part of each covariate in terms of a covariance matrix (or array centers).}

\item{weights}{list(numeric(5)) How heavily each layer contributes to the final result for each covariate}

\item{magnitude}{numeric(ncovariates) The variance over gridcells for each covariate (i.e., sets the relative scale for that covariate)}

\item{family}{character Currently unused}

\item{normalization}{The normalization function to use when computing the rate raster.  This function is used to scale the lambda 'covariate' so that it is within a sensible range.}

\item{grid_proportion_observed}{The percent of gridcells whose value is observed (0-1)}

\item{number_draws}{The number of independent realizations of the underlying distribution}

\item{grid_spatial_observation_bias}{Whether to choose gridcells to observe in a spatially biased way}

\item{grid_temporal_observation_bias}{Whether to choose gridcells to observe in a temporally biased way}

\item{grid_value_observation_bias}{Whether to choose gridcells to observe biased by the number of cases}

\item{noise}{Whether to add noise to the observations}

\item{polygon_proportion_observed}{Percent of polygons observed (for each draw) (0-1)}

\item{polygon_observation_rates}{Not used}

\item{polygon_observation_idx}{integer or NA.  If not NA, then this is the indices of all polygons to observe.}

\item{polygon_size_bias}{Whether or not to sample larger polygons more frequently}

\item{nonlinear_covariates}{Not used}

\item{min_time_left}{The first time associated with an observation}

\item{max_time_right}{The last time associated with an observation}

\item{seed}{integer A seed to use for the randomly constructed portions of this object}
}
\description{
create a testing data set for modeling
}
